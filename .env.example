# ==============================================================================
# SECURITY NOTE: Change all default passwords before production deployment!
# - AUTH_PASSWORD (default: changeme)
# - INITIAL_ADMIN_PASSWORD (default: changeme)
# - POSTGRES_PASSWORD (default: postgres)
#
# When ENVIRONMENT=production, the application will REFUSE TO START if any of
# these credentials are still set to their defaults. This prevents accidental
# deployment with insecure configurations.
# ==============================================================================

# Environment Mode (development, staging, production)
# In production mode:
# - Default credentials are rejected at startup
# - SQL DEBUG logging is disabled to prevent credential exposure
# - Stricter security validation is enforced
ENVIRONMENT=development

# Server Configuration
HOST=0.0.0.0
PORT=8000

# Database Configuration (PostgreSQL)
DATABASE_URL=postgresql+asyncpg://postgres:postgres@localhost:5432/mirror_maestro
# The database volume is marked external in docker-compose.yml to prevent
# accidental deletion via 'docker-compose down -v' or 'docker volume prune'.
# Create it once before first run:
#   ./scripts/create-db-volume.sh
# For development without this protection, copy the override file:
#   cp docker-compose.override.example.yml docker-compose.override.yml

# PostgreSQL credentials (used by docker-compose)
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=mirror_maestro

# Database Connection Pool Settings (for production tuning)
# DB_POOL_SIZE=20           # Number of persistent connections
# DB_POOL_MAX_OVERFLOW=40   # Additional connections under load
# DB_POOL_RECYCLE=3600      # Recycle connections after N seconds
# DB_POOL_PRE_PING=true     # Test connections before use

# Authentication (optional, single-user mode)
AUTH_ENABLED=true
AUTH_USERNAME=admin
AUTH_PASSWORD=changeme

# Multi-User Mode (optional, JWT-based authentication)
# When enabled, individual user accounts can be created
MULTI_USER_ENABLED=false
# Initial admin user (created on first startup when multi-user mode is enabled)
INITIAL_ADMIN_USERNAME=admin
INITIAL_ADMIN_PASSWORD=changeme
INITIAL_ADMIN_EMAIL=
# JWT Settings
# JWT secret is auto-generated and persisted to ./data/jwt_secret.key if not set
# Override with environment variable for containers or custom locations:
# JWT_SECRET_KEY=your-secret-key-here
# JWT_SECRET_KEY_PATH=/path/to/jwt_secret.key
# JWT_ALGORITHM=HS256
# JWT_EXPIRATION_HOURS=24

# Logging
LOG_LEVEL=INFO

# Application Settings
APP_TITLE=Mirror Maestro
APP_DESCRIPTION=Orchestrate GitLab mirrors across multiple instance pairs with precision

# SSL/TLS Configuration
# Set to true to enable HTTPS with SSL/TLS
SSL_ENABLED=false
# Paths to SSL certificate files (inside container)
SSL_CERT_PATH=/etc/nginx/ssl/cert.pem
SSL_KEY_PATH=/etc/nginx/ssl/key.pem
# Optional: Customize ports (default: 80 for HTTP, 443 for HTTPS)
HTTP_PORT=80
HTTPS_PORT=443

# Rate Limiting (for batch operations and imports)
# Delay between GitLab API operations to avoid overwhelming instances
# Default: 200ms = ~300 operations/minute (well under GitLab's typical 600/min limit)
GITLAB_API_DELAY_MS=200
# Number of retries on rate limit errors (with exponential backoff)
GITLAB_API_MAX_RETRIES=3
# Timeout for GitLab API requests in seconds
GITLAB_API_TIMEOUT=60

# Issue Sync Configuration
# Circuit breaker settings for GitLab API resilience
CIRCUIT_BREAKER_FAILURE_THRESHOLD=5
CIRCUIT_BREAKER_RECOVERY_TIMEOUT=60
# Pagination limits to prevent memory exhaustion
MAX_ISSUES_PER_SYNC=10000
MAX_PAGES_PER_REQUEST=100
# Attachment handling (max size in MB, 0 = unlimited)
MAX_ATTACHMENT_SIZE_MB=100
ATTACHMENT_DOWNLOAD_TIMEOUT=30
# Batch processing (issues per checkpoint)
ISSUE_BATCH_SIZE=50
# Graceful shutdown timeout in seconds
SYNC_SHUTDOWN_TIMEOUT=300

# Automatic Mirror Status Refresh
# Periodically refreshes mirror statuses from GitLab in the background
# to keep dashboard health metrics accurate without manual intervention.
# Each cycle refreshes all mirrors, respecting rate limits (~300 ops/min).
# For 300 mirrors this takes ~60 seconds per cycle.
MIRROR_STATUS_REFRESH_ENABLED=true
MIRROR_STATUS_REFRESH_INTERVAL_MINUTES=15

# TLS Keep-Alive (for AWS/enterprise environments with firewall idle timeouts)
# Some network environments drop idle TLS connections, causing mirror failures.
# When enabled, Mirror Maestro maintains persistent openssl s_client connections
# to GitLab instances that have per-instance TLS keep-alive enabled.
# Master switch (must also enable per-instance via the UI or API):
# TLS_KEEPALIVE_ENABLED=false
# Seconds to wait before reconnecting after a connection drops:
# TLS_KEEPALIVE_INTERVAL=5
# TLS version to pass to openssl s_client ("1.2", "1.3", or "" for auto-negotiate):
# TLS_KEEPALIVE_TLS_VERSION=1.2

# ==============================================================================
# ENTERPRISE DEPLOYMENT: INTERNAL NETWORKS
# ==============================================================================
# For enterprise environments with internal GitLab instances on private networks.

# Allow Private IPs (SSRF Protection Override)
# Set to "true" to allow GitLab URLs that resolve to private/internal IP addresses.
# This is REQUIRED for air-gapped or enterprise environments with internal GitLab instances.
# WARNING: This disables SSRF protection for private IP ranges - only enable in trusted environments.
# ALLOW_PRIVATE_IPS=true

# Custom CA Certificate Bundle for GitLab API Connections
# Path to a PEM-format CA bundle file to trust when connecting to GitLab instances
# that use certificates signed by a custom/internal Certificate Authority.
# In Docker: place your CA bundle in ./certs/ and reference it as /app/certs/ca-bundle.crt
# Leave empty (default) to use the system CA bundle.
# CUSTOM_CA_CERT=/app/certs/ca-bundle.crt

# ==============================================================================
# ENTERPRISE DEPLOYMENT: LOCAL ARTIFACT MIRRORS
# ==============================================================================
# For air-gapped or enterprise environments where external internet access is
# restricted, configure these settings to pull artifacts from local mirrors
# (e.g., Nexus, Artifactory, Harbor) instead of public repositories.
#
# Docker Registry Mirror
# Set this to your private Docker registry (e.g., harbor.company.com/)
# Include the trailing slash. Leave empty to use Docker Hub.
# DOCKER_REGISTRY=

# Ubuntu APT Package Mirror
# Set this to your Ubuntu package mirror including the /ubuntu path
# Example: http://nexus.company.com/repository/ubuntu-proxy/ubuntu
# This replaces http://archive.ubuntu.com/ubuntu in the container's sources.list
# Note: Ubuntu 22.04 (Jammy) is used for the base image
# APT_MIRROR=

# APT SSL Certificate Verification Bypass
# Set to "true" to disable SSL certificate verification for APT
# Use this if your environment has corporate proxies with SSL inspection
# or internal mirrors using self-signed certificates
# WARNING: This reduces security - only use when necessary
# APT_SKIP_SSL_VERIFY=

# Python Package Index (PyPI) Mirror
# Set this to your PyPI mirror (e.g., http://nexus.company.com/repository/pypi-proxy/simple)
# Default: https://pypi.org/simple
# PIP_INDEX_URL=https://pypi.org/simple

# PyPI Trusted Host (optional)
# If your PyPI mirror uses HTTP (not HTTPS), add the hostname here
# Example: PIP_TRUSTED_HOST=nexus.company.com
# PIP_TRUSTED_HOST=

# Frontend Vendor Assets (Chart.js and D3.js)
# Set to true to use local copies from /static/vendor instead of CDN
# Run: ./scripts/download-vendor-assets.sh to download vendor files
# USE_LOCAL_VENDOR_ASSETS=false

# Custom CDN URLs (if using a different CDN or local proxy)
# CDN_CHARTJS_URL=https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js
# CDN_D3JS_URL=https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js
